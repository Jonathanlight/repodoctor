use anyhow::Result;

use crate::analyzers::traits::Severity;
use crate::core::scanner::ScanResult;
use crate::core::score::Grade;

use super::traits::Reporter;

pub struct MarkdownReporter;

impl Reporter for MarkdownReporter {
    fn name(&self) -> &str {
        "markdown"
    }

    fn extension(&self) -> &str {
        "md"
    }

    fn generate(&self, result: &ScanResult) -> Result<String> {
        Ok(render_markdown(result))
    }
}

fn grade_emoji(grade: Grade) -> &'static str {
    match grade {
        Grade::A => "A",
        Grade::B => "B",
        Grade::C => "C",
        Grade::D => "D",
        Grade::F => "F",
    }
}

fn severity_badge(severity: Severity) -> &'static str {
    match severity {
        Severity::Critical => "CRITICAL",
        Severity::High => "HIGH",
        Severity::Medium => "MEDIUM",
        Severity::Low => "LOW",
        Severity::Info => "INFO",
    }
}

fn status_text(score: u8) -> &'static str {
    match score {
        80..=100 => "Good",
        60..=79 => "Needs attention",
        _ => "Poor",
    }
}

fn render_markdown(result: &ScanResult) -> String {
    let mut md = String::with_capacity(4096);

    // Title
    md.push_str("# RepoDoctor Health Report\n\n");

    // Project info
    md.push_str("## Project Info\n\n");
    md.push_str(&format!(
        "| Field | Value |\n|-------|-------|\n| **Path** | `{}` |\n| **Framework** | {} {} |\n| **Scan duration** | {:.1}s |\n\n",
        result.project.path.to_string_lossy(),
        result.project.detected.framework,
        result.project.detected.version.as_deref().unwrap_or(""),
        result.duration.as_secs_f64(),
    ));

    // Health score
    md.push_str(&format!(
        "## Health Score: {}/100 (Grade {})\n\n",
        result.score.total,
        grade_emoji(result.score.grade),
    ));

    // Category breakdown
    md.push_str("## Category Breakdown\n\n");
    md.push_str("| Category | Score | Issues | Status |\n");
    md.push_str("|----------|-------|--------|--------|\n");

    for cat in &result.score.breakdown {
        md.push_str(&format!(
            "| {} | {}/100 | {} | {} |\n",
            cat.name,
            cat.score,
            cat.issues_count,
            status_text(cat.score),
        ));
    }
    md.push('\n');

    // Issues
    md.push_str("## Issues\n\n");

    let severity_groups = [
        (Severity::Critical, "Critical"),
        (Severity::High, "High"),
        (Severity::Medium, "Medium"),
        (Severity::Low, "Low"),
        (Severity::Info, "Info"),
    ];

    let mut has_issues = false;
    for (severity, label) in &severity_groups {
        let group: Vec<_> = result
            .issues
            .iter()
            .filter(|i| i.severity == *severity)
            .collect();

        if group.is_empty() {
            continue;
        }
        has_issues = true;

        md.push_str(&format!(
            "### {} ({}) - {} issue(s)\n\n",
            severity_badge(*severity),
            label,
            group.len()
        ));

        for issue in &group {
            md.push_str(&format!("- **{}** - {}", issue.id, issue.title));
            if issue.auto_fixable {
                md.push_str(" *(auto-fixable)*");
            }
            md.push('\n');

            if let Some(file) = &issue.file {
                md.push_str(&format!(
                    "  - File: `{}{}`\n",
                    file.to_string_lossy(),
                    issue
                        .line
                        .map(|l| format!(":{}", l))
                        .unwrap_or_default(),
                ));
            }

            if let Some(suggestion) = &issue.suggestion {
                md.push_str(&format!("  - Suggestion: {}\n", suggestion));
            }
        }
        md.push('\n');
    }

    if !has_issues {
        md.push_str("No issues found!\n\n");
    }

    // Summary
    let total = result.issues.len();
    let critical = result
        .issues
        .iter()
        .filter(|i| i.severity == Severity::Critical)
        .count();
    let high = result
        .issues
        .iter()
        .filter(|i| i.severity == Severity::High)
        .count();
    let fixable = result.issues.iter().filter(|i| i.auto_fixable).count();

    md.push_str("## Summary\n\n");
    md.push_str(&format!(
        "- **{}** issues found ({} critical, {} high)\n",
        total, critical, high,
    ));
    md.push_str(&format!("- **{}** auto-fixable issues\n", fixable));
    md.push_str("\n---\n*Generated by RepoDoctor v0.1.0*\n");

    md
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyzers::traits::{AnalyzerCategory, Issue};
    use crate::core::project::Project;
    use crate::core::score::HealthScore;
    use crate::frameworks::detector::{DetectedProject, Framework, Language};
    use std::time::Duration;

    fn make_result(issues: Vec<Issue>) -> ScanResult {
        let score = HealthScore::calculate(&issues);
        ScanResult {
            project: Project {
                path: "/tmp/test-project".into(),
                detected: DetectedProject {
                    framework: Framework::Symfony,
                    language: Language::Php,
                    version: Some("7.0".to_string()),
                    package_manager: None,
                    has_git: true,
                    has_ci: None,
                },
            },
            issues,
            score,
            duration: Duration::from_millis(500),
        }
    }

    fn make_issue(id: &str, severity: Severity) -> Issue {
        Issue {
            id: id.to_string(),
            analyzer: "test".to_string(),
            category: AnalyzerCategory::Security,
            severity,
            title: "Test issue".to_string(),
            description: "A test issue".to_string(),
            file: None,
            line: None,
            suggestion: Some("Fix it".to_string()),
            auto_fixable: false,
            references: vec![],
        }
    }

    #[test]
    fn test_markdown_report_structure() {
        let result = make_result(vec![make_issue("SEC-001", Severity::Critical)]);
        let reporter = MarkdownReporter;
        let md = reporter.generate(&result).unwrap();

        assert!(md.contains("# RepoDoctor Health Report"));
        assert!(md.contains("## Health Score:"));
        assert!(md.contains("## Category Breakdown"));
        assert!(md.contains("| Category |"));
        assert!(md.contains("SEC-001"));
        assert!(md.contains("CRITICAL"));
        assert!(md.contains("Symfony"));
    }

    #[test]
    fn test_markdown_no_issues() {
        let result = make_result(vec![]);
        let reporter = MarkdownReporter;
        let md = reporter.generate(&result).unwrap();

        assert!(md.contains("100/100"));
        assert!(md.contains("Grade A"));
        assert!(md.contains("No issues found!"));
    }

    #[test]
    fn test_markdown_auto_fixable_marker() {
        let mut issue = make_issue("TST-001", Severity::Low);
        issue.auto_fixable = true;
        let result = make_result(vec![issue]);
        let reporter = MarkdownReporter;
        let md = reporter.generate(&result).unwrap();

        assert!(md.contains("*(auto-fixable)*"));
    }
}
